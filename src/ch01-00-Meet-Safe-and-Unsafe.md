# Safe与Unsafe相遇(Meet Safe and Unsafe)

不必担心低级实现细节会很棒.谁会关心空元组占用多少空间?可悲的是,它有时很重要,我们需要担心它.开发人员开始关注实现细节的最常见原因是性能,但更重要的是,当直接与硬件,操作系统或其他语言交互时,这些细节可能成为正确性问题.

在安全的编程语言中,当实现细节开始重要时,程序员通常有三种选择:

- 调整代码以鼓励编译器/运行时执行优化

- 采用更加统一或繁琐的设计来实现所需的实现

- 用一种可以处理这些细节的语言重写实现

对于最后一个选项,语言程序员倾向于使用C语言.这通常需要与仅声明C接口的系统进行交互.

不幸的是,C使用起来非常不安全(有时候是有充分理由的),当试图与另一种语言进行互操作时,这种不安全会被放大,必须注意确保C和其他语言就正在发生的事情达成一致,并且他们不会互相踩到对方的脚.

那么这与Rust有什么关系呢?

好吧,与C不同,Rust是一种安全的编程语言.

但是,像C一样,Rust是一种不安全的编程语言.

更准确地说,Rust包含安全和不安全的编程语言.

Rust可以被认为是两种编程语言的组合: *Safe Rust* 和 *Unsafe Rust* .方便的是,这些名称正是它们所说的:Safe Rust是安全的.Unsafe Rust不是安全的.事实上,Unsafe Rust让我们做一些 *真正(really)* 不安全的事情.Rust作者会恳求你不要做的事情,但无论如何我们都会做.

Safe Rust是 *真正(true)* 的Rust编程语言.如果你所做的只是编写Safe Rust,你将永远不必担心类型安全或内存安全.你永远不会忍受悬空指针,释放后重用(use-after-free)或任何其他类型的未定义行为.

标准库还为你提供了足够的开箱即用工具,你可以用纯正惯用的Safe Rust编写高性能的应用程序和库.

但也许你想和另一种语言交流.也许你正在编写一个低级抽象,而不是标准库所暴露的.也许你正在 *编写(writing)* 标准库(完全用Rust编写).也许你需要做一些类型系统无法理解的东西,只是 *瞎调一些该死的位(frob some dang bits)* .也许你需要Unsafe Rust.

不安全的Rust与Safe Rust有着完全相同的规则和语义.它只是允许你做一些 *额外的(extra)* 绝对不安全的(我们将在下一节中定义)事情.

这种分离的价值在于我们可以获得使用C等不安全语言的好处--对实现细节的低级控制--没有尝试将其与完全不同的安全语言集成的大多数问题.

仍然存在一些问题--最值得注意的是,我们必须了解类型系统假设的属性,并在与Unsafe Rust交互的任何代码中对其进行审计.这就是本书的目的:教你这些假设以及如何管理它们.
