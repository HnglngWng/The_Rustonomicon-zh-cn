# 替代表示(Alternative representations)

Rust允许你从默认情况下指定替代的数据布局策略.

# repr(C)

这是最重要的`repr`.它意图相当简单:做C做的事情.字段的顺序,大小和对齐方式正是你对C或C++的期望的那样.你希望通过FFI边界传递的任何类型都应该具有`repr(C)`,因为C是编程世界的通用语言.这对于使用数据布局合理地做更精细的技巧也是必要的,例如将值重新解释为不同的类型.

但是,必须牢记与Rust更具异国情调的数据布局功能的相互作用.由于其"用于FFI"和"用于布局控制"的双重目的,`repr(C)`可以应用于通过FFI边界时将是无意义或有问题的类型.

- ZST仍然是零大小的,即使这不是C中的标准行为,并且显然与C++中的空类型的行为相反,C++仍然消耗一个字节的空间.

- DST指针(胖指针),元组和带字段的枚举不是C中的概念,因此不是FFI安全的.

- 如果`T`是FFI安全的非可空指针类型,则`Option<T>`保证具有与`T`相同的布局和ABI,因此也是FFI安全的.在撰写本文时,这涵盖了`&`,`&mut`和函数指针,所有指针都永远不会为空.

- 元组结构类似于`repr(C)`的结构,因为与结构的唯一区别是字段没有命名.

- 对于枚举,这相当于`repr(u*)`(参见下一节).所选大小是目标平台的C应用程序二进制接口(ABI)的默认枚举大小.请注意,C中的枚举表示是实现定义的,因此这实际上是"最佳猜测".特别是,当使用某些标志编译感兴趣的C代码时,这可能是不正确的.

- 具有`repr(C)`或`repr(u*)`的无字段枚举仍然可能不会设置为没有相应变体的整数值,即使这是C或C++中允许的行为.构造与其变体之一不匹配的枚举实例是未定义行为(不安全地).(这样可以继续正常编写和编译详尽的匹配.)

# repr(u*), repr(i*)

这些指定了无字段枚举的大小.如果判别式溢出它必须适合的整数,则会产生编译时错误.你可以通过设置溢出元素显式为0来手动要求Rust允许此操作.但Rust不允许你创建枚举,其中两个变体具有相同的判别式.

术语"无字段枚举(field-less enum)"仅表示枚举任何变体中没有数据.没有`repr(u*)`或`repr(C)`的无字段枚举仍然是Rust原生类型,并且没有稳定的ABI表示.添加`repr`会使其被处理与ABI目的的指定整数大小完全相同.

任何带字段的枚举都是Rust类型,不保证ABI(即使唯一的数据是`PhantomData`或其他零大小的东西).

将明确的`repr`添加到枚举会抑制空指针优化.

这些`reprs`对结构没有影响.

# repr(packed)

`repr(packed)`强制Rust去除任何填充,只将类型与一个字节对齐.这可能会改善内存占用,但可能会产生其他负面影响.

特别是,大多数架构都 *强烈(strongly)* 希望将值对齐.这可能意味着未对齐的加载受到惩罚(x86),甚至是故障(某些ARM芯片).对于直接加载或存储压缩(packed)字段的简单情况,编译器可能能够通过移位和掩码来解决对齐问题.但是,如果你引用压缩字段,则编译器不太可能产生代码以避免未对齐的加载.

**[从Rust 1.0开始,这可能会导致未定义行为.](https://github.com/rust-lang/rust/issues/27060)**

`repr(packed)不能轻易使用.除非你有极端要求,否则不应使用此选项.

这个repr是`repr(C)`和`repr(rust)`的修饰符.